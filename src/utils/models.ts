import { Reflect } from "./reflect.ts";
import {
  ColumnDescription,
  RelationDescription,
  FieldType,
  RelationType,
} from "../models/fields.ts";
import { ExtendedModel, Model } from "../models/model.ts";

/**
 * All models' original values
 */
const originals = new WeakMap();
const isSaved = new WeakMap();

/**
 * Get all columns from a model
 */
export function getModelColumns(modelClass: any): ColumnDescription[] {
  if (!Reflect.hasMetadata("db:columns", modelClass.prototype)) {
    throw new Error("A model should have at least one column!");
  }

  return [
    {
      name: "id",
      propertyKey: "id",
      nullable: false,
      autoGenerated: true,
      select: true,
      isPrimaryKey: true,
      type: FieldType.Number,
    },
    ...Reflect.getMetadata("db:columns", modelClass.prototype),
  ];
}

/**
 * Get all table relations from a model.
 * 
 * @param modelClass the database model class
 * @param includes include several relations and ignore the rest
 */
export function getModelRelations(
  modelClass: any,
  includes?: string[],
): RelationDescription[] {
  const relations: RelationDescription[] =
    Reflect.hasMetadata("db:relations", modelClass.prototype)
      ? Reflect.getMetadata("db:relations", modelClass.prototype)
      : [];
  return includes
    ? relations.filter((item) => includes.includes(item.propertyKey))
    : relations;
}

export function extractRelationalRecord(result: any, tableName: string) {
  const values: { [key: string]: any } = {};

  for (const column in result) {
    if (column.startsWith(tableName + "__")) {
      values[column.slice(tableName.length + 2)] = result[column];
    }
  }

  return values;
}

/**
 * Transform single plain JavaScript object to Model class.
 * 
 * @param modelClass The model class which all the data will be transformed into
 * @param data A plain JavaScript object that holds the model data
 * @param fromDatabase Check whether the data is saved to the database or not
 */
export function createModel<T>(
  modelClass: ExtendedModel<T>,
  data: { [key: string]: any },
  fromDatabase: boolean = false,
): T {
  const relations = getModelRelations(modelClass);

  for (const relation of relations) {
    const relationModel = relation.getModel();
    const relationData = data[relation.propertyKey];

    if (relation.type === RelationType.BelongsTo) {
      if (typeof relationData === "object") {
        data[relation.propertyKey] = createModel(
          relationModel,
          relationData,
          fromDatabase,
        );
      } else {
        data[relation.propertyKey] = null;
      }
    } else if (relation.type === RelationType.HasMany) {
      if (
        Array.isArray(relationData) &&
        relationData.length > 0
      ) {
        data[relation.propertyKey] = createModels(
          relationModel,
          relationData,
          fromDatabase,
        );
      } else {
        data[relation.propertyKey] = [];
      }
    }
  }

  const model = Object.create(modelClass.prototype);
  const result = Object.assign(model, data);

  // Normalize input data
  normalizeModel(result);

  // Set the isSaved value
  setSaved(result, fromDatabase);

  // Save the original values
  saveOriginalValue(result);

  return result;
}

/**
 * Transform an array of plain JavaScript objects to multiple Model classes.
 * 
 * @param modelClass The model class which all the data will be transformed into
 * @param data A plain JavaScript object that holds the model data
 * @param fromDatabase Check whether the data is saved to the database or not
 */
export function createModels<T>(
  modelClass: ExtendedModel<T>,
  data: { [key: string]: any }[],
  fromDatabase: boolean = false,
): T[] {
  return data.map((item) => {
    return createModel(modelClass, item, fromDatabase);
  });
}

/**
 * Normalize model values from the database.
 * 
 * @param model the model you want to normalize
 */
export function normalizeModel<T extends Model>(model: T): T {
  const columns = getModelColumns(model.constructor);

  for (const column of columns) {
    let original = (model as any)[column.propertyKey];
    let value: any;

    if (typeof original === "undefined" || original === null) {
      value = null;
    } else if (column.type === FieldType.Date && !(original instanceof Date)) {
      value = new Date((model as any)[column.propertyKey]);
    } else if (
      column.type === FieldType.String && typeof original !== "string"
    ) {
      value = String((model as any)[column.propertyKey]);
    } else if (
      column.type === FieldType.Number && typeof original !== "number"
    ) {
      value = Number((model as any)[column.propertyKey]);
    } else if (
      column.type === FieldType.Boolean && typeof original !== "boolean"
    ) {
      value = Boolean((model as any)[column.propertyKey]);
    } else {
      value = (model as any)[column.propertyKey];
    }

    (model as any)[column.propertyKey] = value;
  }

  return model;
}

/**
 * Save the original value of a model.
 *
 * @param model Model
 */
export function saveOriginalValue<T extends Model>(model: T): void {
  originals.set(model, model.values());
}

/**
 * Get the original value of a model.
 */
export function getOriginalValue<T extends Model>(model: T): {
  [key: string]: any;
} | undefined {
  return originals.get(model);
}

/**
 * Update the `isSaved` status of a model.
 *
 * @param model the model you want to change the status
 * @param value the status of the model (saved or not saved)
 */
export function setSaved<T extends Model>(model: T, value: boolean): void {
  isSaved.set(model, value);
}

/**
 * Check wether this model is saved or not.
 *
 * @param model the model you want to check the status
 */
export function getSaved<T extends Model>(model: T): boolean {
  return isSaved.get(model) ? true : false;
}

/**
 * Map raw SQL JOIN result.
 *
 * @param modelClass the main model
 * @param includes which relations are included in this query
 * @param result the query result itself
 */
export function mapRelationalResult<T>(
  modelClass: ExtendedModel<T>,
  includes: string[],
  result: any[],
): any[] {
  const relations = getModelRelations(modelClass, includes);

  return result.reduce((prev, next) => {
    if (
      prev.length !== 0 &&
      prev[prev.length - 1].id === next[getTableName(modelClass) + "__id"]
    ) {
      for (const relation of relations) {
        if (relation.type === RelationType.HasMany) {
          const data = extractRelationalRecord(
            next,
            getTableName(relation.getModel()),
          );
          prev[prev.length - 1][relation.propertyKey] =
            (prev[prev.length - 1][relation.propertyKey] || [])
              .concat(data);
        }
      }
    } else {
      const data = extractRelationalRecord(next, getTableName(modelClass));

      for (const relation of relations) {
        const tableName = getTableName(relation.getModel());

        if (relation.type === RelationType.HasMany) {
          if (next[tableName + "__id"] === null) {
            data[relation.propertyKey] = [];
          } else {
            data[relation.propertyKey] = [
              extractRelationalRecord(next, tableName),
            ];
          }
        } else if (relation.type === RelationType.BelongsTo) {
          if (next[tableName + "__id"] === null) {
            data[relation.propertyKey] = null;
          } else {
            data[relation.propertyKey] = extractRelationalRecord(
              next,
              tableName,
            );
          }
        }
      }

      prev.push(data);
    }

    return prev;
  }, []);
}

/**
 * Get the default table name from a model class
 */
export function getTableName(modelClass: typeof Model): string {
  return modelClass.tableName
    ? modelClass.tableName
    : modelClass.name.toLowerCase() + "s";
}
